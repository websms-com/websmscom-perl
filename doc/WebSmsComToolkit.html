<html><head><title>WebSmsComToolkit</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="style" type="text/css" href="http://st.pimg.net/tucs/style.css" media="all" >

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008008 at Wed Sep 21 13:54:26 2016 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#FEATURES'>FEATURES</a>
    <li class='indexItem indexItem2'><a href='#Classes'>Classes</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#A_FEW_NOTES_ON_UNICODE_AND_PERL'>A FEW NOTES ON UNICODE AND PERL</a>
  <li class='indexItem indexItem1'><a href='#EXAMPLES'>EXAMPLES</a>
  <ul   class='indexList indexList2'>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Info_on_how_to_set_UTF-8_or_Unicode_message_content'>Info on how to set UTF-8 or Unicode message content</a>
      <li class='indexItem indexItem3'><a href='#TextMessage'>TextMessage</a>
      <li class='indexItem indexItem3'><a href='#BinaryMessage'>BinaryMessage</a>
      <li class='indexItem indexItem3'><a href='#ConvergedMessage'>ConvergedMessage</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#LIMITATIONS'>LIMITATIONS</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SECURITY_CONSIDERATIONS'>SECURITY CONSIDERATIONS</a>
  <li class='indexItem indexItem1'><a href='#THREADS'>THREADS</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>WebSmsComToolkit - SMS Client</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre> # sending a text message
 
 use WebSmsComToolkit;
 
 # 1. create client
 
  $sms_client  = WebSmsComToolkit::Client-&#62;new( &#34;https://api.websms.com&#34;,
                                                &#34;username&#34;,
                                                &#34;password&#34;);
 
 # 2. create a message
 
 $sms_message = WebSmsComToolkit::TextMessage-&#62;new( $recipient_address_list, 
                                                    $utf8_message_text);
 
 # 3. send message
 
 $response    = $sms_client-&#62;send( $sms_message, 
                                   $max_sms_per_message, 
                                   $test);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module can be used to create a reusable sms client over which you can send created <i>TextMessages</i> or <i>BinaryMessages</i>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="FEATURES"
>FEATURES</a></h2>

<ul>
<li>correct Unicode handling</li>

<li>convenient API communication <i>(uses LWP::Useragent to post JSON to BusinessPlatform API)</i></li>

<li>simple to use
<p>You should not need to play around with the HTTP Request itself</p>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Classes"
>Classes</a></h2>

<dl>
<dt><a name="WebSmsComToolkit::Client"
><b>WebSmsComToolkit::Client</b></a></dt>

<dd>
<pre>  $sms_client  = WebSmsComToolkit::Client-&#62;new( &#34;https://api.websms.com&#34;,
                                                &#34;username&#34;,
                                                &#34;password&#34;);</pre>

<dt><a name="$client-&#62;verbose($bool)"
><i>$client-&#62;verbose($bool)</i></a></dt>

<dd>
<p>set/get verbose - print HTTP Transfer to STDOUT</p>

<pre>  $sms_client-&#62;set_verbose(1);</pre>

<dt><a name="$client-&#62;user_agent()"
><i>$client-&#62;user_agent()</i></a></dt>

<dd>
<p>direct access to LWP::UserAgent object</p>

<pre>  $sms_client-&#62;user_agent();
  
  # for setting connection timeout use
  $sms_client-&#62;timeout(10);</pre>

<dt><a name="$client-&#62;timeout($seconds)"
><i>$client-&#62;timeout($seconds)</i></a></dt>

<dd>
<p>Set connection timeout in seconds</p>

<pre>  $sms_client-&#62;timeout(10);</pre>

<dt><a name="$client-&#62;send($message_object,_$max_sms_per_message,_$test)"
><i>$client-&#62;send($message_object, $max_sms_per_message, $test)</i></a></dt>

<dd>
<p>Send Message.</p>

<p>$message object must be of type (<i>WebSmsComToolkit::TextMessage</i>, <i>WebSmsComToolkit::BinaryMessage</i> or <i>WebSmsComToolkit::ConvergedMessage</i>)</p>

<pre>  # send text message (1 SMS)
  $text_message = WebSmsComToolkit::TextMessage-&#62;new( [&#39;4367612345678&#39;], &#39;Hallo Welt!&#39;);
  
  $sms_client-&#62;send($text_message, 1);
  
  # send binary message (2 SMS)
  $binary_message = WebSmsComToolkit::BinaryMessage-&#62;new( 
                      [&#39;4367612345678&#39;], [&#39;BQAD/AIBWnVzYW1tZW4=&#39;,&#39;BQAD/AICZ2Vmw7xndC4=&#39;]);
  
  $response = $sms_client-&#62;send($binary_message) or die &#34;LWP Connection error.&#34;;

  # send converged message (1 SMS)
  my $additional_push_parameters = { &#39;key&#39; =&#62; &#39;value&#39; };
  $converged_message = WebSmsComToolkit::ConvergedMessage-&#62;new(
                      [&#39;4367612345678&#39;], &#39;Hallo Welt!&#39;, $additional_push_parameters);
  
  $sms_client-&#62;send($converged_message, 1);
  
  # Response success:
  # $response = {
  #        &#39;transferId&#39;    =&#62; &#39;005065a89200043a409e&#39;,
  #        &#39;statusMessage&#39; =&#62; &#39;OK&#39;,
  #        &#39;statusCode&#39;    =&#62; 2000
  #      }
  if ($response-&#62;{&#39;statusCode&#39;} == 2000 || $response-&#62;{&#39;statusCode&#39;} == 2001) {
    print &#34;Message transferred. transferId: &#34;.$response-&#62;{&#39;statusCode&#39;}.&#34;\n&#34;;
  }

  #
  # Response error (HTTP or server error):
  # $response = {
  #        &#39;error&#39;        =&#62; 1, # always 1
  #        &#39;http_status&#39;   =&#62; &#39;OK&#39;,
  #        &#39;error_content&#39; =&#62; 2000
  #      }
  if ($response-&#62;{&#39;error&#39;}) {
    print $response-&#62;{&#39;http_status&#39;}.&#34;\n&#34;.$response-&#62;{&#39;error_content&#39;};
  }</pre>

<dt><a name="WebSmsComToolkit::TextMessage"
><b>WebSmsComToolkit::TextMessage</b></a></dt>

<dd>
<p>Message Object for Text Messages</p>

<pre>  $sms_message = WebSmsComToolkit::TextMessage-&#62;new( $recipient_address_list, 
                                                     $utf8_message_text);</pre>

<dt><a name="$message-&#62;message_content($utf8_text)"
><i>$message-&#62;message_content($utf8_text)</i></a></dt>

<dd>
<p>set/get message_content (sms text)</p>

<pre>  $message-&#62;message_content(&#34;Eurozeichen: \xE2\x82\xAC&#34;);</pre>

<dt><a name="WebSmsComToolkit::BinaryMessage"
><b>WebSmsComToolkit::BinaryMessage</b></a></dt>

<dd>
<p>Message Object for Binary Messages</p>

<pre>  $sms_message = WebSmsComToolkit::BinaryMessage-&#62;new(  $recipient_address_list, 
                                                        $bas64_encoded_message_segments_arrayref,
                                                        $userDataHeaderPresent);</pre>

<dt><a name="$message-&#62;message_content($arrayref)"
><i>$message-&#62;message_content($arrayref)</i></a></dt>

<dd>
<p>set/get message_content (arrayref of strings containing base64 encoded binary)</p>

<pre>  $message-&#62;message_content([&#39;BQAD/AIBWnVzYW1tZW4=&#39;,&#39;BQAD/AICZ2Vmw7xndC4=&#39;]);</pre>

<dt><a name="$message-&#62;user_data_header_present($bool)"
><i>$message-&#62;user_data_header_present($bool)</i></a></dt>

<dd>
<p>set/get user_data_header_present</p>

<pre>  # the base64 encoded binary already contains user data header
  $message-&#62;message_content([&#39;BQAD/AIBWnVzYW1tZW4=&#39;,&#39;BQAD/AICZ2Vmw7xndC4=&#39;]);
  $message-&#62;user_data_header_present(1);</pre>

<dt><a name="WebSmsComToolkit::ConvergedMessage"
><b>WebSmsComToolkit::ConvergedMessage</b></a></dt>

<dd>
<p>Message Object for Converged Messages</p>

<pre>  $sms_message = WebSmsComToolkit::ConvergedMessage-&#62;new( $recipient_address_list, 
                                                          $utf8_message_text,
                                                          $parameter_hash);</pre>

<dt><a name="$message-&#62;additional_push_parameters($parameter_hash)"
><i>$message-&#62;additional_push_parameters($parameter_hash)</i></a></dt>

<dd>
<p>set/get additional_push_parameters (parameter hash)</p>

<pre>  $message-&#62;additional_push_parameters({ &#39;key&#39; =&#62; &#39;value&#39;});</pre>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="A_FEW_NOTES_ON_UNICODE_AND_PERL"
>A FEW NOTES ON UNICODE AND PERL</a></h1>

<p>Since this often leads to confusion, here are a few very clear words on how Unicode works in Perl, modulo bugs.</p>

<dl>
<dt><a name="1._Perl_strings_can_store_characters_with_ordinal_values_&#62;_255."
>1. Perl strings can store characters with ordinal values &#62; 255.</a></dt>

<dd>
<p>This enables you to store Unicode characters as single characters in a Perl string - very natural.</p>

<dt><a name="2._Perl_does_not_associate_an_encoding_with_your_strings."
>2. Perl does <i>not</i> associate an encoding with your strings.</a></dt>

<dd>
<p>... until you force it to, e.g. when matching it against a regex, or printing the scalar to a file, in which case Perl either interprets your string as locale-encoded text, octets/binary, or as Unicode, depending on various settings. In no case is an encoding stored together with your data, it is <i>use</i> that decides encoding, not any magical meta data.</p>

<dt><a name="3._The_internal_utf-8_flag_has_no_meaning_with_regards_to_the_encoding_of_your_string."
>3. The internal utf-8 flag has no meaning with regards to the encoding of your string.</a></dt>

<dd>
<p>The flag tells string operations to regard utf-8 characters and usually prevents multibyte characters from being cut in the middle. You can have Unicode strings with that flag set, with that flag clear, and you can have binary data with that flag set and that flag clear. Other possibilities exist, too.</p>

<p>If you didn&#39;t know about that flag, just the better, pretend it doesn&#39;t exist.</p>

<dt><a name="4._A_&#34;Unicode_String&#34;_is_simply_a_string_where_each_character_can_be_validly_interpreted_as_a_Unicode_code_point."
>4. A &#34;Unicode String&#34; is simply a string where each character can be validly interpreted as a Unicode code point.</a></dt>

<dd>
<p>If you have UTF-8 encoded data, it is no longer a Unicode string, but a Unicode string encoded in UTF-8, giving you a binary string.</p>

<dt><a name="5._A_string_containing_&#34;high&#34;_(&#62;_255)_character_values_is_not_a_UTF-8_string."
>5. A string containing &#34;high&#34; (&#62; 255) character values is <i>not</i> a UTF-8 string.</a></dt>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLES"
>EXAMPLES</a></h1>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Info_on_how_to_set_UTF-8_or_Unicode_message_content"
>Info on how to set UTF-8 or Unicode message content</a></h3>

<p>These 3 message examples are all valid and show how to <b>set</b> but do <b>not</b> describe how to <b><i>convert</i></b> string encodings to utf8:</p>

<p>See <a href="http://perldoc.perl.org/Encode.html" class="podlinkurl"
>http://perldoc.perl.org/Encode.html</a> for <b>conversion</b></p>

<dl>
<dt><a name="1.)_Source_code_itself_is_written_in_utf-8:"
>1.) Source code itself is written in utf-8:</a></dt>

<dd>
<pre>  use utf8;
  $utf8_message_content = &#34;Euro-sign: &#8364;&#34;  # where the euro sign is 3 bytes \xE2\x82\xAC</pre>

<dt><a 
>2.) is the same as in 1.) but source code itself is for example in iso-8859-15, latin1 or cp1252 etc. Decode(flag) perl internal string containing 3 bytes (utf8) for euro sign as utf-8 string (Encode::decode)</a></dt>

<dd>
<pre>  use Encode;
  my $utf8_message_content = decode(&#34;utf-8&#34;,&#34;Hallo Welt! Eurozeichen: \xE2\x82\xAC&#34;);</pre>

<dt><a name="3.)_is_like_2.)_but_using_unicode"
>3.) is like 2.) but using unicode</a></dt>

<dd>
<pre>  my $unicode_message_content = &#34;Euro-sign: \x{000020AC}&#34;); # 4bytes</pre>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="TextMessage"
>TextMessage</a></h3>

<p>Fully working sample (put WebSmsComToolkit.pm somewhere where perl can find it or set $path_to_toolkit):</p>

<pre>  #!/usr/bin/perl
  my $path_to_toolkit = &#39;&#39;; #&#39;&#60;path to WebSmsComToolkit.pm&#62;&#39;
  unshift(@INC, $path_to_toolkit) if ($path_to_toolkit ne &#39;&#39;);
  
  use WebSmsComToolkit;
  use Encode;

  my ($sms_client, $message, $response);

  # --- Modify these values to your needs ---
  my $gateway_url          = &#39;https://api.websms.com&#39;;
  my $username             = &#39;your username&#39;;
  my $password             = &#39;your password&#39;;
  my $recipients           = [&#39;4367612345678&#39;];
  my $utf8_message_content = decode(&#34;utf-8&#34;,&#34;Hallo Welt! Eurozeichen: \xE2\x82\xAC&#34;);
  my $max_sms_per_message  = 1;
  my $test                 = 0; # // 1: do not send sms but test interface, 0: send sms

  # --- 1. create client, 2. create message, 3. send message --- 
  $sms_client = WebSmsComToolkit::Client-&#62;new($gateway_url, $username, $password);
  $sms_client-&#62;verbose(1);

  $message = WebSmsComToolkit::TextMessage-&#62;new($recipients, $utf8_message_content);

  $response = $sms_client-&#62;send($message, $max_sms_per_message, $test);

  if (exists($response-&#62;{&#39;error&#39;})) {
    
    # HTTP or server error
    print $response-&#62;{&#39;http_status&#39;}.&#34;\n&#34;.$response-&#62;{&#39;error_content&#39;};
        
  } else {
  
    # read return values from API
    if ($response-&#62;{&#39;statusCode&#39;} == 2000 || $response-&#62;{&#39;statusCode&#39;} == 2001) {
      print &#34;SMS sent, transferId: &#34;.$response-&#62;{&#39;transferId&#39;}.&#34;\n&#34;;
    } else {
      print &#34;statusCode   : &#34;.$response-&#62;{&#39;statusCode&#39;}.&#34;\n&#34;;
      print &#34;statusMessage: &#34;.$response-&#62;{&#39;statusMessage&#39;}.&#34;\n&#34;;
    }
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="BinaryMessage"
>BinaryMessage</a></h3>

<p>Fully working sample (put WebSmsComToolkit.pm somewhere where perl can find it or set path):</p>

<pre>  #!/usr/bin/perl
  my $path_to_toolkit = &#39;&#39;; #&#39;&#60;path to WebSmsComToolkit.pm&#62;&#39;
  unshift(@INC, $path_to_toolkit) if ($path_to_toolkit ne &#39;&#39;);
  
  use WebSmsComToolkit;
  use Encode;

  my ($sms_client, $message, $response);

  # --- Modify these values to your needs ---
  my $gateway_url              = &#39;https://api.websms.com&#39;;
  my $username                 = &#39;your username&#39;;
  my $password                 = &#39;your password&#39;;
  my $recipients               = [&#39;4367612345678&#39;];
  my $message_content          = [&#39;BQAD/AIBWnVzYW1tZW4=&#39;,&#39;BQAD/AICZ2Vmw7xndC4=&#39;]; # &#34;Zusammen&#34;,&#34;gef&#252;gt.&#34;
  my $max_sms_per_message      = undef;
  my $user_data_header_present = 1;
  my $test                     = 0; # // 1: do not send sms but test interface, 0: send sms

  # --- 1. create client, 2. create message, 3. send message --- 
  $sms_client = WebSmsComToolkit::Client-&#62;new($gateway_url, $username, $password);
  $sms_client-&#62;verbose(1);
  
  $message = WebSmsComToolkit::BinaryMessage-&#62;new($recipients, $message_content, $user_data_header_present);

  $response = $sms_client-&#62;send($message, undef, $test);

  if (exists($response-&#62;{&#39;error&#39;})) {
    
    # HTTP or server error
    print $response-&#62;{&#39;http_status&#39;}.&#34;\n&#34;.$response-&#62;{&#39;error_content&#39;};
        
  } else {
  
    # read return values from API
    if ($response-&#62;{&#39;statusCode&#39;} == 2000 || $response-&#62;{&#39;statusCode&#39;} == 2001) {
      print &#34;SMS sent, transferId: &#34;.$response-&#62;{&#39;transferId&#39;}.&#34;\n&#34;;
    } else {
      print &#34;statusCode   : &#34;.$response-&#62;{&#39;statusCode&#39;}.&#34;\n&#34;;
      print &#34;statusMessage: &#34;.$response-&#62;{&#39;statusMessage&#39;}.&#34;\n&#34;;
    }
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="ConvergedMessage"
>ConvergedMessage</a></h3>

<p>Fully working sample (put WebSmsComToolkit.pm somewhere where perl can find it or set $path_to_toolkit):</p>

<pre>  #!/usr/bin/perl
  my $path_to_toolkit = &#39;&#39;; #&#39;&#60;path to WebSmsComToolkit.pm&#62;&#39;
  unshift(@INC, $path_to_toolkit) if ($path_to_toolkit ne &#39;&#39;);
  
  use WebSmsComToolkit;
  use Encode;

  my ($sms_client, $message, $response);

  # --- Modify these values to your needs ---
  my $gateway_url                = &#39;https://api.websms.com&#39;;
  my $username                   = &#39;your username&#39;;
  my $password                   = &#39;your password&#39;;
  my $recipients                 = [&#39;4367612345678&#39;];
  my $utf8_message_content       = decode(&#34;utf-8&#34;,&#34;Hallo Welt! Eurozeichen: \xE2\x82\xAC&#34;);
  my $max_sms_per_message        = 1;
  my $additional_push_parameters = { &#39;key&#39; =&#62; &#39;value&#39; };
  my $test                 = 0; # // 1: do not send sms but test interface, 0: send sms

  # --- 1. create client, 2. create message, 3. send message --- 
  $sms_client = WebSmsComToolkit::Client-&#62;new($gateway_url, $username, $password);
  $sms_client-&#62;verbose(1);

  $message = WebSmsComToolkit::ConvergedMessage-&#62;new($recipients, $utf8_message_content, $additional_push_parameters);

  $response = $sms_client-&#62;send($message, $max_sms_per_message, $test);

  if (exists($response-&#62;{&#39;error&#39;})) {
    
    # HTTP or server error
    print $response-&#62;{&#39;http_status&#39;}.&#34;\n&#34;.$response-&#62;{&#39;error_content&#39;};
        
  } else {
  
    # read return values from API
    if ($response-&#62;{&#39;statusCode&#39;} == 2000 || $response-&#62;{&#39;statusCode&#39;} == 2001) {
      print &#34;SMS sent, transferId: &#34;.$response-&#62;{&#39;transferId&#39;}.&#34;\n&#34;;
    } else {
      print &#34;statusCode   : &#34;.$response-&#62;{&#39;statusCode&#39;}.&#34;\n&#34;;
      print &#34;statusMessage: &#34;.$response-&#62;{&#39;statusMessage&#39;}.&#34;\n&#34;;
    }
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="LIMITATIONS"
>LIMITATIONS</a></h2>

<p>Yet unknown....</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SECURITY_CONSIDERATIONS"
>SECURITY CONSIDERATIONS</a></h1>

<p>uses SSL endpoint</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="THREADS"
>THREADS</a></h1>

<p>not tested.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>They usually fly around in places where you never expect them.</p>

<p>Feel free to report them, we happily fixed them ever after.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>In case you have any problems using this package, you can easily omit it and send the requests yourself, see following full example without error handling: Take a look at our API specification at https://api.websms.com</p>

<pre>    #!/usr/bin/perl
    use strict;
    #use utf8;
    use Encode;
    use LWP::UserAgent;
    use JSON::XS qw(encode_json decode_json);
    use Data::Dumper;
    
    my $sms_client = LWP::UserAgent-&#62;new;
       $sms_client-&#62;timeout(10); 
    
    my $url      = &#34;https://api.websms.com&#34;;
    my $username = &#34;your_username&#34;;
    my $password = &#34;your_password&#34;;
      
    my $header = HTTP::Headers-&#62;new(Content_Type =&#62; &#39;application/json; charset=UTF-8&#39;);
    
    $header-&#62;authorization_basic($username, $password);
      
    # Text Message  
    my $endpoint   = &#39;/json/smsmessaging/text&#39;;
    my $Message    = {
        &#39;test&#39;                    =&#62; JSON::XS::false, # or JSON::XS::true
        &#39;recipientAddressList&#39;    =&#62; [4367612345678],
        #  messageContent without real utf-8 encoding can also be 
        #  described with unicode escaped characters &#34;\x{000020AC}urozeichen&#34;
        &#39;messageContent&#39;          =&#62; decode(&#39;utf-8&#39;,&#34;\xE2\x82\xACurozeichen&#34;), 
        &#34;sendAsFlashSms&#34;          =&#62; JSON::XS::false, 
        &#34;notificationCallbackUrl&#34; =&#62; &#34;http://your_domain/endpoint&#34;, 
        &#34;clientMessageId&#34;         =&#62; &#34;myMessageId123&#34;, 
        &#34;priority&#34;                =&#62; 1, 
    
      };
    
    ## Binary Message
    #  my $endpoint   = &#39;/json/smsmessaging/binary&#39;;
    #  my $Message    = {
    #    &#39;test&#39;                    =&#62; JSON::XS::false, # or JSON::XS::true
    #    &#39;recipientAddressList&#39;    =&#62; [4367612345678],
    #    &#39;messageContent&#39;          =&#62; [&#39;BQAD/AIBWnVzYW1tZW4=&#39;,&#39;BQAD/AICZ2Vmw7xndC4=&#39;],
    #    &#34;userDataHeaderPresent&#34;   =&#62; JSON::XS::true,  #binary
    #    #&#34;senderAddress&#34;          =&#62; &#34;4367600000001&#34;, 
    #    #&#34;senderAddressType&#34;      =&#62; &#34;international&#34;, 
    #    &#34;sendAsFlashSms&#34;          =&#62; JSON::XS::true, 
    #    &#34;notificationCallbackUrl&#34; =&#62; &#34;http://your_domain/endpoint&#34;, 
    #    &#34;clientMessageId&#34;         =&#62; &#34;myMessageId123&#34;, 
    #    &#34;priority&#34;                =&#62; 1, 
    #  };
      
    $url        .= $endpoint;
    my $content  = encode_json($Message);
    my $request  = HTTP::Request-&#62;new(&#39;POST&#39;, $url, $header, $content);
    my $response = $sms_client-&#62;request($request); 
      
    print &#34;Request:\n----\n&#34;  . $request-&#62;as_string() . &#34;\n----\n&#34;;
    print &#34;Response:\n----\n&#34; . $response-&#62;as_string(). &#34;\n----\n&#34;;
      
    my $answer         = decode_json($response-&#62;content);
      
    my $status_code    = $answer-&#62;{&#39;statusCode&#39;};
    my $status_message = $answer-&#62;{&#39;statusMessage&#39;};
    my $transfer_id    = $answer-&#62;{&#39;transferId&#39;};
      
    if ($response-&#62;is_success) {
      
      print &#34;Request was sucessful.\n&#34;;
      print &#34;statusCode   : $status_code\n&#34;;
      print &#34;statsMessage : $status_message\n&#34;;
      print &#34;TransferId   : $transfer_id\n&#34;;
    
    } elsif ($response-&#62;is_error) {
      print &#34;HTTP error code   : &#34;.$response-&#62;code.&#34;\n&#34;;
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Gerd Reifenauer &#60;gerd.reifenauer@websms.com&#62;</p>

<p>http://websms.com/</p>
<p class="backlinkbottom"><b><a name="___bottom" href="index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
